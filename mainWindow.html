<!DOCTYPE html>
<html lang="en">

<head>

  <!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src
       see above for hashing specific scripts
       TODO - for now using unsafe-inline -- eventually may want to secure this
       with specifics
       TODO - may want to inject these into session instead per Electron guide
  -->
  <meta http-equiv="Content-Security-Policy"
    content="default-src
      'self'
      'unsafe-inline'
      https://jquery.com/
      https://code.jquery.com/
      https://cdnjs.cloudflare.com/
      https://fonts.googleapis.com/
      https://fonts.gstatic.com/
      https://d3js.org ">
  </meta>

  <title>DacqMan</title>

  <!-- https://stackoverflow.com/questions/32621988/electron-jquery-is-not-defined -->
  <!-- Insert this line above script imports  -->
  <script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>

  <script
	  src="https://code.jquery.com/jquery-3.3.1.min.js"
	  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
	  crossorigin="anonymous">
  </script>
  <!-- UI allows such things as color transitions, though these are available
       through other routes as well -->
  <script
	  src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"
	  integrity="sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU="
	  crossorigin="anonymous">
  </script>


  <!-- Materialize -->
  <!-- Materialize CDNs -->
  <!-- Compiled and minified CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
  <!--Import Google Icon Font-->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <!-- Compiled and minified JavaScript -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
  <!--Let browser know website is optimized for mobile-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <!-- End Materialize -->

  <!-- Plotting / Charting / Data Visualization
       v3 to keep the refs to d3.scale.linear()
       v5 will start using eg d3.scaleLinear
       Previously using v3        d3.v4.min.js                  -->
  <!--<script src="https://d3js.org/d3.v4.min.js"></script>-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.7.0/d3.min.js"></script>

  <link rel="stylesheet" href="css/custom.css">

  <!-- Paired with pre-script line - to allow same code for electron app and
       browser-based implementations in theory -->
  <!-- Insert this line after script imports -->
  <script>if (window.module) module = window.module;</script>

</head>



<body>
  <header></header>



  <!--
  ******************************************************************************
          MAIN
  ******************************************************************************
  -->

  <main>
    <!-- TODO yeah, figure out the sicenav application and update when to show
         as well as the burger icon and why media query overrides are not
         working  -->
    <nav>
      <!--<a href="#" data-target="slide-out" class="sidenav-trigger"><i class="material-icons">menu</i></a>-->
      <div class="nav-wrapper">
        <a href="" class="brand-logo center"> (click to reload this App)</a>
        <!--<a href="#" data-target="slide-out" class="sidenav-trigger"><i class="material-icons">menu</i></a>-->
      </div>
    </nav>
    <!-- <a href="#" data-target="slide-out" class="sidenav-trigger"><i class="material-icons">menu</i></a> -->
    <!-- I kinda miss bootstrap sometimes ... -->

    <ul></ul>


    <ul id="serialPortSelectionAccordion" class="collapsible collapsible-accordion">
      <li class="active">
        <a class="collapsible-header">Serial Port Selection
          <i class="material-icons medium sidenav-dd-expand">play_arrow</i>
        </a>
        <div class="collapsible-body">

          <h6>Virtual Serial Port (VCP) Devices</h6>
          <div id="vcp_error"></div>
          <div id="vcp_ports"></div>

          <h6>FTDI-Driver (D2XX, etc.) Devices</h6>
          <div id="ftdi_error"></div>
          <div id="ftdi_ports"></div>

          <!--<hr />-->

          <ul class="collapsible collapsible-accordion">
            <li>
              <a class="collapsible-header">Notes about the port discovery and implementation
                <i class="material-icons medium sidenav-dd-expand">play_arrow</i>
              </a>
              <div class="collapsible-body">
                <div id="ports-info">
                  <p>Note: These are serial ports returned by serialport which means that
                    your device would be listed here if is intended to enumerate as a serial
                    port, real or virtual.  For example, using the FTDI VCP driver.
                  </p>
                  <p>
                    However, if your device is intended to be accessed as an FTDO D2XX driver
                    device target, then you should/will not see it in this listing until
                    the d2xx device listing is added to this code.  You can still click SELECTME
                    at any serial device here and you'll then see the buttons to test access to the
                    first detected d2xx FTDI device.
                  </p>
                  <p>
                    The FTDI (D2XX) devices are listed in the console.log output, so you can
                    see which device is at index 0 (and thus the device to be opened).
                  </p>
                </div>
              </div>
            </li>
          </ul>

          <div id="ports_go_button"></div>

        </div>
      </li>
    </ul>




    <!-- TODO place into card or section, etc.-->
    <div id="active_ports_ui_indicators" class="row">

      <div id="active_ports_ui_buttons" class="hide col s4">
        <!--Controls<br>-->
        <button id="btnDataPortStatus" class="btn-small blue hide" onclick="btnDataPortClick(this)" title="Click to Close/Open Data Streaming Port">
          Data Port
        </button>
        <button id="btnControlPortStatus" class="btn-small blue hide" onclick="btnControlPortClick(this)" title="Click to Expand">
          Control Port
        </button>
      </div>

      <div id="active_ports_ui_status_indicators" class="hide col s8">
        <!--Status<br>-->
        <button id="btnListeningForData" class="btn-small blue lighten-4 disabled right">Listening for Data</button>
        <button id="btnBufferOverflowing" class="btn-small lighten-2 disabled right">Buffer Overflowing</button>
        <button id="btnSilenceIndicators" class="btn-small blue lighten-4 disabled right" onclick="silenceIndicators(this)">Silence Flashers</button>
      </div>

    </div>



    <!-- .......................................... --><!--
    ***********************************************
      CARD - Serial Port Buttons / Controls (Init no display)
    *********************************************** -->
    <!-- Could add 2 levels of grid containment to this card section -->
    <div id="activeSerialPortStuff" class="card teal lighten-4" style="display:none;">
      <div class="card-content">
        <span class="card-title">Selected Serial Port:&nbsp;
          <span id="activePort"></span>
        </span>
        <br>
        <div class="container-buttons">
          Available controls:
          <div class="card-action">
            <p>Standard Buttons</p>
            <span id="serialOpenBtnSpan">
              <button name="serialOpenBtn" id="serialOpenBtn" onclick="serialOpen()">Open</button></span>
            <span id="serialCloseBtnSpan">
              <button name="serialCloseBtn" id="serialCloseBtn" onclick="serialClose()">Close</button></span>
            <span id="serialTestWriteSpan">
              <button name="serialTestWrite" id="serialTestWrite" onclick="serialTestWrite()">Test Write</button></span>
          </div>
          <div class="card-action">
            <p>Custom Buttons Loaded From File:</p>
            <div id="serialButtonsFromFileDiv"></div>
          </div>
        </div>
      </div>
    </div>







    <!-- .......................................... --><!--
    ***********************************************
      CARD - Control Port Buttons / Controls (Init no display)
    *********************************************** -->
    <!-- Could add 2 levels of grid containment to this card section -->
    <div id="activeControlPort" class="card teal lighten-4" style="display:none;">
      <div class="card-content">
        <span class="card-title">Control Port:&nbsp;
          <span id="activeControlPortName"></span>
        </span>
        <br>
        <div id="container-buttons" class="container-buttons">

          <ul class="collapsible collapsible-accordion">
            <li>
              <a class="collapsible-header">Standard Buttons and Generic Command Send Tool
                <i class="material-icons medium sidenav-dd-expand">play_arrow</i>
              </a>
              <div class="collapsible-body">
                <div class="row">
                  <div class="card-action col s5">
                    <!--<p class="custom-control-section">Standard Buttons and Generic Command Send Tool</p>-->
                    <!--<span id="controlPortOpenBtnSpan">-->
                      <button name="controlPortOpenBtn" id="controlPortOpenBtn" onclick="controlPortOpen(this)" >
                        Open
                      </button>
                    <!--</span>-->
                    <!--<span id="controlPortCloseBtnSpan">-->
                      <button name="controlPortCloseBtn" id="controlPortCloseBtn" onclick="controlPortClose(this)" >
                        Close
                      </button>
                    <!--</span>-->
                    <!--<span id="controlTestWriteSpan">
                      <button name="controlPortTestWrite" id="controlPortTestWrite" onclick="controlTestWrite()">Test Write</button></span>-->
                  </div><!-- s5 -->
                  <div class="card-action col s7"> <!-- row"> -->
                    <!--<div class="col s7">-->
                      <div class="row">
                        <div id="sendButtonSpan" class="col s2 right-align">
                          <button id="sendButton" onclick="controlPortSendStuff()">Send</button>
                        </div>
                        <div id="stuffToSendSpan" class="col s10">
                          <div class="input-field">
                            <i class="material-icons prefix">account_circle</i>
                            <input type="text" id="stuffToSend" placeholder="Put (or Type) some stuff here to send" class="validate">
                            <label for="stuffToSend">Stuff to Send</label>
                            <span class="helper-text" data-error="wrong" data-success="right">Type (a) char(s) to send as ASCII=>0xhh</span>
                          </div>
                        </div>
                      </div>
                    <!--</div>-->
                  </div><!-- s7 -->
                </div><!-- row -->
              </div><!-- collapsible-body -->
            </li><!-- collapsible li -->
          </ul><!-- collapsible ul -->


          <ul class="collapsible collapsible-accordion">
            <li class="active">
              <a class="collapsible-header">Custom Controls Loaded From File
                <i class="material-icons medium sidenav-dd-expand">play_arrow</i>
              </a>
              <div class="collapsible-body">
                <div class="card-action">
                  <!--<p class="custom-control-section">Custom Control Buttons Loaded From File</p>-->
                  <div id="controlPortButtonsFromFileDiv" class="row"></div>
                </div>
              </div>
            </li>
          </ul>

        </div>
      </div>
    </div>







    <!-- .......................................... --><!--
    ***********************************************
      CARD - Chart
    *********************************************** -->
    <ul class="collapsible collapsible-accordion">
      <li class="active">
        <a class="collapsible-header">Single (Channel) Waveform Data View(s)
          <i class="material-icons medium sidenav-dd-expand">play_arrow</i>
        </a>
        <div class="collapsible-body">

          <div class="row">
            <div class="col s12"><!-- was col s12 m7 -->
              <div class="card blue-grey darken-1">
                <div class="card-content white-text">
                  <span class="card-title">
                    <span class="chart-title">Waveform Display</span>
                  </span>
                  <div id="chart"></div>
                  <div class="card-action">
                    <!--<a href="#">-->Double-click chart background to reset zoom<!--</a>-->
                  </div>
                </div>
              </div>
            </div>
          </div>

        </div><!-- collapsible-body -->
      </li><!-- collapsible li -->
    </ul><!-- collapsible ul -->







    <!-- .......................................... --><!--
    ***********************************************
      CARD - Multipane-Chart
    *********************************************** -->
    <ul class="collapsible collapsible-accordion">
      <li>
        <a class="collapsible-header">Multi-Waveform Data View(s)
          <i class="material-icons medium sidenav-dd-expand">play_arrow</i>
        </a>
        <div class="collapsible-body">

          <div class="row">
            <div class="col s12"><!-- was col s12 m7 -->
              <div class="card blue-grey darken-1">
                <div class="card-content white-text">
                  <span class="card-title">
                    <span class="chart-title">Multi-Waveform Display</span>
                  </span>
                  <div id="divMultichart" class="flex-container"></div>
                  <div class="card-action">
                    <!--<a href="#">-->Double-click chart background to reset zoom<!--</a>-->
                  </div>
                </div>
              </div>
            </div>
          </div>

        </div><!-- collapsible-body -->
      </li><!-- collapsible li -->
    </ul><!-- collapsible ul -->







    <!-- .......................................... --><!--
    ***********************************************
      CARD - Output console-like
    *********************************************** -->
    <div class="row"><div class="col s12">
        <div class="card blue-grey darken-1">
          <div class="card-content white-text">
            <span class="card-title">
              <span class="output-title">Output</span>
            </span>
            <div id="output">
              <pre class="preserve-whitespace pre-scrollable">
                <span id="output">Output log</span>
              </pre>
            </div>
            <div class="card-action">
              <a href="#">Link</a>
            </div>
          </div>
        </div>
    </div></div>






  </main><!-- main -->

<!-- end container div ? -->






  <!--
  ******************************************************************************
          NAVIGATION
  ******************************************************************************
  -->

  <!--
      https://materializecss.com/sidenav.html
      https://materializecss.com/navbar.html
  -->

  <ul id="slide-out" class="sidenav">
    <li><a class="sidenav-close" href="#!" onclick="showUserPrefsData();">User Prefs Data</a></li>
    <li><a href="#!" class="sidenav-close" onclick="copyCustomCommandsToLocalFile();">Copy Cmds to Local</a></li>
    <li class="no-padding">
      <ul class="collapsible collapsible-accordion">
        <li>
          <a class="collapsible-header">Utilities<i class="material-icons">arrow_drop_down</i></a>
          <div class="collapsible-body">
            <ul>
              <li><a class="sidenav-close" href="#!" onclick="resetPrefsToDefaults();">Reset Prefs to Defaults</a></li>
              <li><a href="#!">Second</a></li>
              <li><a href="#!">Third</a></li>
              <li><a href="#!">Fourth</a></li>
            </ul>
          </div>
        </li>
      </ul>
    </li>
  </ul>

  <a href="#" data-target="slide-out" class="sidenav-trigger"><i class="material-icons">settings</i></a>



























  <!--
  ******************************************************************************
          SCRIPT
  ******************************************************************************
  -->


  <script type="text/javascript">

    // Dev Notes to Self
    // Note that document.getElementById("myBtn").addEventListener('click', myFcn)
    // will work when Content-Security-Policy (CSP) does not allow
    // inline event handlers, like if CSP: script-src https://example.com/
    // See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src




    const electron = require('electron');
    const {ipcRenderer } = electron;
    const { dialog } = require('electron').remote; // is remote needed?
    const ul = document.querySelector('ul');
    const fs = require('fs');


    // https://stackoverflow.com/questions/36980201/how-to-reset-nodejs-stream

    // Create stream object for access by both sprenderer and charting
    //const dataBuf = Buffer.alloc(100*4096, 0);
    //const streamBuffers = require('stream-buffers');
    const rsb = require('./readable_streambuffer.js');
    const stream = require('stream');
    // On platform for testing: using standard node stream buffers:
    // At freq of 10 (ms)
    // - chunkSize of 2 * 4095 gives steady sync graph, with eventual huge buffer (overrun)
    // - chunkSize of 3 * 4095 gives walking graph and glitches due to emptiness (underrun)
    var singleChartBuf = Buffer.alloc(4095,127); //null;
    var ourReadableStreamBuffer = null;
    var writeStream = null;
    var captureDataFileOutputBatch = null;
    var currentWriteStreamFilepath = null;
    var currentBytesCaptured = null;
    var currentMaxCaptureFileSizeBytes = null;
    var gChunkMultiple = null;
    var gReturnDataTo = "chart";
    var resetReadableStream = function(chunkMultiple) {
      curChan = 0;
      singleChartBuf =  Buffer.alloc(4095, 127);
      // changing below to 20ms (and doubling the chunksize) doesn't stop the
      // crash malloc errors
      //chunkMultiple = 33; // 33 in our testing gives split between 8 chans, and no buffer overflow
      chunkMultiple = chunkMultiple || 3; // default to 3x
      gChunkMultiple = chunkMultiple;
      ourReadableStreamBuffer = new rsb.ReadableStreamBuffer({
        frequency: 10,       // in milliseconds // 5 or 7 was ok // 10 less crashy // less than 7ms to be faster than incoming packets of 4096
        chunkSize: (chunkMultiple*4095), //16380, //(4095)//,     // bytes -- 4096 gives a left-ward walk -- 4095 was generally steady
        initialSize: (100 * 1024),    // was 1000 // added these two for size management due to constant overflow
        //incrementAmount: (10 * 1024)  // zero does nothing - doesn't cap it
      });

      // Set up dumping all to file
      // Right so yeah - this will only go to the file, all of it
      // and we don't get any screen updates --
      // So fix the piping to mult distination via some intermediary readable stream?
      // Or we can perhaps manually handle the data in the chunk-tion below.
      // For 2 mins we got 62.4MB at default encoding
      // 128 * 4096 bytes ish * 120 = ... yes so, /1024 / 1024 => 60 MB ish or so
      /*if ( writeStream ) {
        ourReadableStreamBuffer.pipe(writeStream);
      }*/

      ourReadableStreamBuffer.on('readable', function(data) {

        try {
          var chunk;
          //console.log(ourReadableStreamBuffer.size());
          if ( ourReadableStreamBuffer.size() > (1000*1024) ) {
            console.log(ourReadableStreamBuffer.size());
            $('#btnBufferOverflowing').removeClass('disabled').addClass('orange pulse');
            //console.log("ALERT: ourReadableStreamBuffer is larger than ...1MB ... dumping data ...");
            // Do something to dump or pause this
            //ourReadableStreamBuffer.pause(); // no effect in a readable event listener
            //console.log("new ourReadableStreamBuffer size: " + ourReadableStreamBuffer.size());
          } else {
            // TODO LT this is a lot of overhead to do every time?
            $('#btnBufferOverflowing').removeClass('orange pulse').addClass('disabled');
          }
          // Could try to:
          // - Increment the decimation counter here instead and it talks to the sprendered code
          // or
          // - Use 'data' event subscription instead and then use pause and resume to allow
          //   screen plotting to catch up
          while((chunk = ourReadableStreamBuffer.read()) !== null) {
            //assert.isTrue(chunk instanceof Buffer);
            //console.log(chunk.length);
            //console.log('t');
            // could implement skipping code here - take every 8th and plot it
            //n = (n > 8) ? 0 : n;
            //if ( n === 8 ) {

            //console.log("chunk read of length: " + chunk.length);
            //console.log(chunk);

            // deimation stuff: no dice - not a copy must not be the bottleneck
            //dataPushDecimationCounter++; // increment only with each chunk
            //if ( dataPushDecimationCounter > decimationValue ) {
            //  dataPushDecimationCounter = 0;
            //}
            //if ( dataPushDecimationCounter === decimationValue ) {
            // TODO - add try catches for all memory stuff to catch serial port
            // (data port) errors that might be creating the malloc errors in these
            // revisions
            var selectedChan = 1;
            chunk.copy(singleChartBuf, 0, 0, 4096);
            // Big TODO - clean up from Demo mode
            if ( gChunkMultiple > 3 && selectedChan == curChan ) {
              singleWfChart.UpdateChartBuffer(singleChartBuf);
            }
            if ( gChunkMultiple < 4 ) {
              singleWfChart.UpdateChartBuffer(singleChartBuf);
            }
            //singleWfChart.UpdateChartBuffer(singleChartBuf);

            // Now for chan scans:
            curChan = curChan == 8 ? 0 : curChan;
            multiWfs[curChan].UpdateChartBuffer(singleChartBuf);
            curChan++;

            // TODO can we just set up a simple pipe instead, since we want all
            // the data going to file? -- see above quick test ... need more on it
            // TODO -- need of course to end the stream at events and thus close
            // the file -- just a reminder at stopping point to do this next ...
            // Yeah this approach seems to allow watching the live WF updates on the
            // screen and also the file is getting built --
            // Now using hex encoding, we'll see the size after 2 mins to see if
            // got it all ...
            // 63,194,040 bytes - yeah, all data is there => / 128 / 120 seconds => 4114.2 byte chunks which is about right
            // Cool.
            // TODO could do a manual file close button, to allow contnuous adding
            // to file?
            if ( writeStream ) {
              if ( currentMaxCaptureFileSizeBytes ) {
                if ( currentBytesCaptured < currentMaxCaptureFileSizeBytes ) {
                  //currentBytesCaptured += chunk.length; // since we're calling this a "max" size for now we put this before the write
                  writeStream.write(chunk, 'hex');
                  currentBytesCaptured += chunk.length;
                  // TODO implement exact difference calculation at the edge
                  // versus just stopping writing after the chunk
                  // TODO LT could switch the logic to notify user and other
                  // processes to cancel.
                  // We're still in system demo rapid drafting mode ...
                }
              }
            }




            //
            //
            // if ( capture file output set )
            if ( captureDataFileOutputBatch ) {
              captureDataFileOutputBatch.ReceiveData(chunk);
            }



            //
            //
            //




            // Debugging:
            //console.log(chartBuf.slice(0,11)); // checking the SOF section
            // The 5th bit [4] is the sequence_id - it begins at 1 and wraps after 255
            // Thus we are only counting 255 WFs maximum (not 256)
            // Though, need to check that after the RST signal - as this is for
            // just after power up as for the first WF returning 1 for seq_id


            //}
            //}
            //n++;
            // nope the n thing still allows the internal buffer to grow ... and slow
            //console.log(n);
          }
        } catch (e) {
          console.log("Error in readable event: " + e);
        }
      });
    }





    // From SP EG
    // You can also require other files to run in this process
    const sprend = require('./sprenderer.js')
    //const chartRend = require('./chartRend.js')
    //const chart = require('./simpleChartRend.js')
    const SingleWfDataChart = require('./bigWfDataChart.js');

    // Add item
    ipcRenderer.on('item:add', function(e, item){
      ul.className = 'collection';
      const li = document.createElement('li');
      li.className = 'collection-item';
      const itemText = document.createTextNode(item);
      li.appendChild(itemText);
      ul.appendChild(li);
    });

    // Clear items
    ipcRenderer.on('item:clear', function(){
      ul.innerHTML = '';
      ul.className = '';
    });


    // TODO - need to use some kind of buffer management here
    // sprenderer (FTDI/D2XX) Port data received from peripheral device
    // TODO - we're not really using ipc here -- fix this -- clean up / remove
    ipcRenderer.on('port:ondata', function(e, data){
      chart.update(data);
    });


    ipcRenderer.on('log', function(e, data) {
      console.log("ipc log event: " + data);
    });




    function showUserPrefsData() {
      console.log("sending prefs:show from ipcRenderer");
      ipcRenderer.send('prefs:show');
    }
    ipcRenderer.on('prefs:show', function(e, data) {
      console.log("prefs:show: " + JSON.stringify(data));
    });

    function resetPrefsToDefaults() {
      console.log("resetting prefs to defaults...");
      ipcRenderer.send('prefs:reset');
    }


    // Prevent Closing when work is running
    window.onbeforeunload = (e) => {
      //e.returnValue = false;  // this will *prevent* the closing no matter what value is passed

      //if(confirm('Do you really want to close the application?')) {
      //  win.destroy();  // this will bypass onbeforeunload and close the app
      //}

      ipcRenderer.send('prefs:storeWindowBounds');

    };





    var animStarted = false;
    function mainWindowUpdateChartData(data) {
      //chart.update(data);
      //return;

      console.log("mainWindowUpdateChartData: gReturnDataTo: " + gReturnDataTo);

      if ( data !== null ) {
        console.log("ERROR: mainWindowUpdateChartData is not implemented \
          in this configuration for regular calls.  Currently, chart is expected to use    \
          requestAnimationFrame and thus just the first call initiates the looped calls.");
      }

      if ( !animStarted ) {
        resetReadableStream();   // Or move to data Port event handler for close()?
        console.log("mainWindowUpdateChartData: animStarted = false, calling renderChart()");
        //chart.renderChart(); // This initiates the loop
        singleWfChart.RenderChart();
        animStarted = true;

        if ( gReturnDataTo === "multiChart") {
          var i = 0;
          for ( i = 0 ; i < 8 ; i++ ) {
            multiWfs[i].RenderChart();
          }
        }

        // TODO finish mult-chart implementation


        // Update the UI status indicator showing Graph/Data Listening

      } else {
        // clearReadStream??? or just reset it too?
        console.log("mainWindowUpdateChartData: animStarted = true, calling cancelRenderChart()");
        //chart.cancelRenderChart();
        singleWfChart.CancelRenderChart();
        animStarted = false;

        // TODO finish multi-chart implementation
        // TODO conditional for gReturnDataTo === "multiChart" ???
        if ( gReturnDataTo === "multiChart") {
          var i = 0;
          for ( i = 0 ; i < 8 ; i++ ) {
            multiWfs[i].CancelRenderChart();
          }
        }

        // Update the UI status indicator showing Graph/Data Not Listening

      }
    }

    // Remove item on double-click from main  list
    ul.addEventListener('dblclick', removeItem);

    function removeItem(e){
      e.target.remove();
      if(ul.children.length == 0){
        ul.className = '';
      }
    }

    // Serial port -- TODO MOVE & DRY
    function serialSelect(button) {
      var d = document.querySelector("#activePort");
      $('#activeSerialPortStuff').show();
      d.innerHTML = button.name;
    }
    function serialCheckbox(checkbox) {
      //alert(checkbox.checked); // yeah the property works, even with the materializecss
      sprend.serialCheckbox(checkbox);
    }
    function serialOpen() {
      var d = document.querySelector("#activePort");
      var spname = d.innerHTML;
      sprend.serialOpenByName(spname);
    }
    function serialClose() {
      sprend.serialClose();
    }
    function controlPortClose() {
      //console.log("cpClose");
      sprend.controlPortClose();
    }
    function controlPortOpen() {
      sprend.controlPortOpen();
    }
    function serialTestWrite() {
      sprend.serialTestWrite();
    }
    function serialSendData(commandAndType, returnDataTo) {
      sprend.serialSendData(commandAndType, returnDataTo);
    }
    function controlPortSendData(commandAndType, returnDataTo, button) {
      // We capture and send the button item as well to be able parse and handle
      // any options that are not specified at the command level of the tree
      sprend.controlPortSendData(commandAndType, returnDataTo, button);
    }
    function beginSerialComms() {
      sprend.beginSerialComms();
    }
    function btnDataPortClick(button) {
      sprend.btnDataPortClick(button);
    }
    function btnControlPortClick(button) {
      sprend.btnControlPortClick(button);
    }
    function controlPortSendStuff() {
      sprend.controlPortSendStuff($('#stuffToSend'));
    }
    function controlPortSendDataFromTextInput(button, commandAndType) {
      sprend.controlPortSendDataFromTextInput(button, commandAndType);
    }
    function silenceIndicators(button) {
      $("#btnListeningForData").removeClass('pulse');
      $("#btnDataPortStatus").removeClass('pulse');
      $(button).addClass('disabled');
    }
    function cancelCustomControlButtonCommand() {
      sprend.cancelCustomControlButtonCommand();
    }



    // Chart / graphing / data view items
    var singleWfChart = new SingleWfDataChart({
      parentElementIdName: "chart",
      chartBuffer: singleChartBuf
    });

    var multiWfs = [];
    var multiWfBufs = [];
    var curChan = 0;
    var prefs;
    var customCommandsFilePath;
    var customCommandsJson;



    // Be careful with sendSync - even though we need it here to guarantee the
    // return of the prefs for next code, if there is a hang up, reload and quit
    // stop working and you need for force quit somehow (Ctrl-c command line
    // or some app force quit menu items somewhere ... apparently)
    let getPrefsPromise = () => {
      return new Promise((resolve, reject) => {
        prefs = ipcRenderer.sendSync('prefs:getPrefs') || {};
        console.log("Prefs: " + JSON.stringify(prefs));
        if ( !prefs ) {
          reject("getPrefsPromise: failed to get prefs");
        } else {
          resolve(prefs);
        }
      });
    }


    let  loadCustomCommandsPromise = (prefs) => {

      // TODO there is probably a problem with the try/catch inside the promise
      return new Promise((resolve, reject) => {

        // What happens if custom file and user deletes it?
        customCommandsFilePath = prefs.customCommandsFilePath || '';

        fs.stat(customCommandsFilePath || '', function (err, stat) {
          if ( !err ) {
            console.log("Loading customCommandsFilePath: " + customCommandsFilePath);
            customCommandsJson = require(customCommandsFilePath) || '';
            resolve(customCommandsJson);
          } else {
            console.log("Filepath in preferences for customCommandsFilePath, " + customCommandsFilePath + ", does not exist ... defaulting to packaged fallback");
            try {
              customCommandsJson = require(prefs.customCommandsFilePathPackaged);
              resolve(customCommandsJson);
            } catch (e) {
              console.log("Problem loading customCommandsFilePathPackaged..." + e);
              customCommandsJson = JSON.parse("{}");
              console.log(customCommandsJson);
              reject(customCommandsJson);
            }
          }
        });
      }); // end of new Promise

    }









    // TODO wrap pass-through functions above and thus DRY ...

    // Materialize - sidenav support
    // Without jQuery
    /*document.addEventListener('DOMContentLoaded', function() {
      var options = {};
      var elems = document.querySelectorAll('.sidenav');
      var instances = M.Sidenav.init(elems, options);
    });*/

    // Initialize collapsible (uncomment the lines below if you use the dropdown variation)
    // var collapsibleElem = document.querySelector('.collapsible');
    // var collapsibleInstance = M.Collapsible.init(collapsibleElem, options);

    // Or with jQuery:
    // Materialize inits
    // For both browser and electron app work, this needs the script pre and
    // post load items in the head section to prevent undefined $ or jQuery etc
    //jQuery(document).ready(function($){
    $(document).ready(function(){
    //window.onload = function(){


      // Wow - I don't believe this actually works ...
      // It does ... so far.  Improvements to clean it up?
      getPrefsPromise()
        .then(prefs => loadCustomCommandsPromise(prefs))
        .then( function(customCommandsJson) {
          loadButtons(customCommandsJson);
          $(".switch").find("input[type=checkbox]").attr('checked', true);
          showCustomControlsAsRangeSliders(true, customCommandsJson);
          $('.collapsible').collapsible({
            accordion: true
          });
        })
        .catch ( e => {
          console.log("Error loading prefs and customCommandsJson from file: " + e);
        })



      //loadButtons(customCommandsJson);




      // Check for stuff that needs to execute on page load after population
      //serialCheckbox(); // arg not used ... TODO better way to do this of course

      // Check for stuff that needs to execute on page load after population
      // For our win32 VM 8.1 Pro - this timeout lets things load on launch
      // and then fires the test to see if we can show the proceed button
      // Without it, the button doesn't show, as not all is loaded in time
      // Easy to update for other sequential functionality of course.
      setTimeout( function() {
        serialCheckbox(); // arg not used ... TODO better way to do this of course
      }, 2000);


      // TODO - parametrize and customizable / settings / create object
      const nChans = 8;
      setupMultipaneCharts($("#divMultichart"), nChans);




      // Let's start by showing the text inputs as sliders - seems better for UI demo
      //$(".switch").find("input[type=checkbox]").attr('checked', true);
      //showCustomControlsAsRangeSliders(true, customCommandsJson);

      $('.sidenav').sidenav();
      $(".dropdown-trigger").dropdown();
      //$('.collapsible').collapsible({
      //  accordion: true
      //});

    });





    var setupMultipaneCharts = function (parentEle, nChans) {

      var i;
      multiWfs = [];
      multiWfBufs = [];
      for ( i = 0; i < nChans; i++ ) {
        var buf = Buffer.alloc(4095, 127);
        var idName = "divMultipaneChart" + i;
        var dChartBlock = $(document.createElement("div"))
          .addClass("col s12 m6 l4")
          ;
        var dHeader = $(document.createElement("div"))
          .addClass("divMultiChartTitleArea")
          .text("Channel " + (i+1))
          ;
        var d = $(document.createElement("div"))
          .addClass("multipaneChart") // col s12 m6 l4")
          .attr("id", idName)
          ;


        $(dChartBlock).append(dHeader).append(d);
        $(parentEle).append(dChartBlock);

        multiWfBufs.push(buf);
        var multiWfDataChart = new SingleWfDataChart({
          parentElementIdName : idName,
          title: "Channel " + (i+1),
          chartBuffer : buf
        });
        multiWfs.push(multiWfDataChart);



      }

    }





    var showCustomControlsAsRangeSliders = function ( boolShowAsSliders, customCommandsJson ) {
      if ( boolShowAsSliders ) {

        parseAndShowCustomTextInputsAsRangeSliders(customCommandsJson);

      } else {

        parseAndShowCustomTextInputsAsButtonsAndTextInputs(customCommandsJson);

      }
    }






    function loadButtons(customCommandsJson) {

      console.log("loadButtons: customCommandsJson: " + customCommandsJson); // JSON.stringify(customCommandsJson||''));

      // TODO use meta list for button files to be loaded and for various port-style devices

      // TODO this is kinda rambling, no?

      // Basic test functions and single-port style device buttons (aka DLITE legacy)
      // Can use user data path instead when running live not dev
      // Previous generation of basic default buttons for demos ...
      const path = "./user-data/buttons-example.json"
      var buttons = require(path).buttons;
      console.log(buttons.length + " buttons found.");
      buttons.forEach( function (b) {
        var newb = $('<button/>')
          .text(b.title)
          .prop('title', b.description)
          .click(function () {
            //alert(b.command.type + ': ' + b.command.value)
            serialSendData(b.command, b.returnDataTo);
          });
        $('#serialButtonsFromFileDiv').append(newb);
      });


      //const cp_path = "./user-data/control-port-buttons.json"
      // At current development, textInputs is at the top level
      // while controlGroups have buttons children
      //var controlGroups = require(cp_path).controlGroups;
      var controlGroups = customCommandsJson.controlGroups;
      if ( !controlGroups) {
        console.log("No control groups in customCommandsJson ... returning");
        return;
      }

      var collButtonNodes = $($.parseHTML(
            '<ul class="collapsible collapsible-accordion">'
          + '  <li class="active">'
          + '   <a class="collapsible-header">Custom Control Buttons Loaded From File'
          + '      <i class="material-icons medium sidenav-dd-expand">play_arrow</i>'
          + '   </a>'
          + '   <div id="divCustomControlButtons" class="collapsible-body"></div>'
          + '  </li>'
          + '</ul>'
        ));

      var cgRow = $(document.createElement("div"))
        .attr("id", "divCtrlGrp")
        .addClass("row")
        ;
      controlGroups.forEach( function ( cg ) {
        var buttons = cg.buttons;
        var d = $(document.createElement("div"))
          .attr("id", "divCtrlGrp" + cg.name.replace(/\s/g,''))
          .addClass("control-group col s4")
          ;
        var groupTitle = $(document.createElement("p"))
          .text(cg.name)
          .addClass("control-group")
          ;
        d.append(groupTitle);
        console.log(buttons.length + " control port buttons in controlGroup " + cg.name + " found.");
        buttons.forEach( function (b) {
          var newb = $('<button/>')
            .text(b.title)
            .prop('title', b.description)
            .click(function () {
              controlPortSendData(b.command, b.returnDataTo, b);
            });
          d.append(newb);
        });
        cgRow.append(d);
      });

      // Append now a UI feedback group
      var d = $(document.createElement("div"))
        .attr("id", "divCtrlGrpBtnUiFeedback")
        .addClass("control-group col s4")
        ;
      var groupTitle = $(document.createElement("p"))
        .text("Command Progress")
        .addClass("control-group")
        ;
      d.append(groupTitle);

      var pbar = $(document.createElement("div"))
        .attr("id", "divProgressBar")
        .addClass("progress")
        .append($.parseHTML('<div id="theBarItself" class="determinate" style="width: 0%;"></div>'))
        ;
      d.append(pbar);

      var cancelAndOutput = $(document.createElement("div"))
        .addClass("row")
        ;
      var cancelb = $(document.createElement("button"))
        .addClass("cancel")
        .click( function() {
          cancelCustomControlButtonCommand();
        })
        .append($.parseHTML('<i class="small material-icons">cancel</i>'))
        ;
      var dbtn = $(document.createElement("div"))
        .addClass("col s2")
        ;
      dbtn.append(cancelb);
      cancelAndOutput.append(dbtn);

      var logTicker = $(document.createElement("div"))
        .addClass("col s9")
        .attr("id","divControlActionLog")
        .append($.parseHTML(''
            + '<pre class="mini">'
            +   '<div id="cmdOutput">Cmd replies...\r\n</div>'
            + '</pre>'
          ))
        ;

      cancelAndOutput.append(logTicker);
      d.append(cancelAndOutput);
      cgRow.append(d);



      $(collButtonNodes).find('.collapsible-body').append(cgRow);
      $('#controlPortButtonsFromFileDiv').append(collButtonNodes); //(cgRow);

      // End of buttons added to control groups added to the div

      // Add text input to range slider switch and header
      // in collapsible

      var collVariableInputNodes = $($.parseHTML(
            '<ul class="collapsible collapsible-accordion">'
          + '  <li class="active">'
          + '   <a class="collapsible-header">Custom Control Range Sliders/Text inputs Loaded From File'
          + '      <i class="material-icons medium sidenav-dd-expand">play_arrow</i>'
          + '   </a>'
          + '   <div id="divCustomControlVariableInputs" class="collapsible-body"></div>'
          + '  </li>'
          + '</ul>'
        ));

      var swChk = $('<input />', { type: 'checkbox' });
      var swSpLev = $(document.createElement("span"))
        .addClass("lever");
      var swLbl = $(document.createElement("label"))
        .append("Text Inputs")
        .append(swChk)
        .append(swSpLev)
        .append("Range Sliders")
        ;
      var switchRangeOrTextInput = $(document.createElement("div"))
        .addClass("switch")
        .append(swLbl)
        ;
      var textInputControlTitle = $(document.createElement("p"))
        .text("Custom Control Text Inputs Loaded From File")
        .addClass("custom-control-section")
        .append(switchRangeOrTextInput)
        ;

      $(collVariableInputNodes).find('.collapsible-body').append(textInputControlTitle);
      $('#controlPortButtonsFromFileDiv')
        //.append(textInputControlTitle)
        .append(collVariableInputNodes);
        ;

      $(".switch").find("input[type=checkbox]").on("change",function() {
        var boolShowAsRangeSlider = $(this).prop('checked');
        showCustomControlsAsRangeSliders(boolShowAsRangeSlider, customCommandsJson);
      });

      parseAndShowCustomTextInputsAsButtonsAndTextInputs(customCommandsJson);

    }






    var loadTextInputs = function (customCommandsJson) {

      // Dual-port style functions
      //
      // Control port
      //const cp_path = "./user-data/control-port-buttons.json"
      // At current development, textInputs is at the top level
      // while controlGroups have buttons children
      //var controlGroups = require(cp_path).controlGroups;
      //var buttons = require(cp_path).buttons;
      //var textInputs = require(cp_path).textInputs;
      var textInputs = customCommandsJson.textInputs;

      return textInputs;

    }








    var parseAndShowCustomTextInputsAsRangeSliders = function(customCommandsJson) {

      var textInputs = loadTextInputs(customCommandsJson);

      if ( !textInputs || textInputs.length < 1 ) {
        return;
      }

      $("div[id^='divTextInputRow']")
        .remove()
        ;

      var inputRowDiv = $('<div>')
        .prop('id', "divTextInputRow") // + inputCnt)
        .addClass("row")
        ;

      var myAddTo = $('#divCustomControlVariableInputs'); // $('#controlPortButtonsFromFileDiv');

      var theRangeForm = $(document.createElement("form"))
        .attr("action", "#");

      textInputs.forEach( function(ti) {
        var range = $(document.createElement("p"))
          .text(ti.label)
          .addClass("range-field")
          .append($('<input />', { type: 'range'
            , class: 'control-range'
            , id: 'range' + ti.label.replace(/\s/g, '')
            , min: ti.min, max: ti.max, step: 1
            , value: ti.default
          }));
        $(range).on("change", function() {
          controlPortSendDataFromTextInput(this, ti.command);
        });
        theRangeForm.append(range);
      });

      inputRowDiv.append(theRangeForm);
      myAddTo.append(inputRowDiv);

      M.Range.init($('.control-range')); //$('input[type="range"]')); // or this

    }








    var parseAndShowCustomTextInputsAsButtonsAndTextInputs = function (customCommandsJson) {

      var textInputs = loadTextInputs(customCommandsJson);

      if ( textInputs.length < 1 ) {
        return;
      }

      $("div[id^='divTextInputRow']")
        .remove()
        ;

      var inputCnt = 1;
      var inputRowDiv = $('<div>')
        .prop('id', "divTextInputRow" + inputCnt)
        .addClass("row")
        ;
      // To make 3 pairs per row, change below from s2 to s3
      // and change below further: % 4 to % 3 (change the modulus)
      textInputs.forEach( function (ti) {
        var smallDiv = $('<div>')
          .addClass("col s2 right-align");
        var smallDiv2 = $('<div>')
          .attr("id", "div" + ti.label.replace(/\s/g, ''))
          .addClass("col s1 left-align");
        //var wrapTogether = $('<div>')
        //  .addClass("text-input-pair");
        //console.log($(ti.label.split(" ")).last());
        var span = $("<span>").text(ti.label.split(" ").pop()); //ti.label);
        var input = $("<input type='text'>")
          .addClass("input-field")
          .prop('title', ti.description)
          .prop('id', "input" + ti.label.replace(/\s/g,''));
        var button = $("<button>")
          .text(ti.label)
          .addClass("btn-small waves-effect waves-light")
          .prop('id', "button" + ti.label.replace(/\s/g, ''))
          .click(function () {
            controlPortSendDataFromTextInput(this, ti.command);
          });
        var label = $("<label>")
          .attr("for", ti.label.replace(/\s/g,''));
        $(label).append(input).append(span);
        var c1 = $(smallDiv).append(button);
        var c2 = $(smallDiv2).append(label);
        //$(wrapTogether).append(c1).append(c2);
        //$(inputRowDiv).append(wrapTogether); // c1).append(c2);
        $(inputRowDiv).append(c1).append(c2);
        // Create the text inputs, grouped by rows of 3
        console.log("inputCnt: " + inputCnt + " textInputs.length: " + textInputs.length );
        if ( inputCnt % 4 == 0 ) {
          //$('#controlPortButtonsFromFileDiv').append(inputRowDiv);
          $('#divCustomControlVariableInputs').append(inputRowDiv);
          inputRowDiv = $('<div>')
            .prop('id', "divTextInputRow" + inputCnt)
            .addClass("row")
            ;
        } else if ( inputCnt == textInputs.length ) {
          //$('#controlPortButtonsFromFileDiv').append(inputRowDiv);
          $('#divCustomControlVariableInputs').append(inputRowDiv);
        }
        inputCnt++;
      });

    }






    var copyCustomCommandsToLocalFile = function() {

      // https://stackoverflow.com/questions/11293857/fastest-way-to-copy-file-in-node-js
      // destination.txt will be created or overwritten by default.
      var currentWriteStreamFilepath;
      currentWriteStreamFilepath = dialog.showSaveDialog( {
        options : {
          title : 'Copy the customizable command controls file locally to ...',
          buttonLabel: 'Copy'
        }
      });
      console.log("file picker result: " + currentWriteStreamFilepath);
      const app = require('electron').remote.app;
      var a = app.getAppPath();
      console.log("getAppPath: " + a);
      var path = require('path');
      var srcFilePath = path.join(a, prefs.customCommandsFilePathPackaged);
      console.log("srcFilePath: " + srcFilePath);
      if ( !currentWriteStreamFilepath ) {
        console.log("no file selected for copy custom control file to ... returning.");
      } else {
        console.log("selected " + currentWriteStreamFilepath + " for copy custom control file to...")
        cancelThis = fs.copyFile(srcFilePath, currentWriteStreamFilepath, (err) => {
          if (err) {
            console.log("error copying the source file to the destination file, for copy custom command control packaged file to local. " + err);
          } else {
            console.log('source.txt was copied to destination.txt ... storing path as pref also.');
            ipcRenderer.send('prefs:set', { 'key' : 'customCommandsFilePath', 'value' : currentWriteStreamFilepath});
            // And reload into the local copy
            prefs = ipcRenderer.sendSync('prefs:getPrefs');
          }
        });
      }

    };



  </script>

</body>
</html>
